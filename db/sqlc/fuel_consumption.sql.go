// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: fuel_consumption.sql

package db

import (
	"context"
	"time"
)

const createCar = `-- name: CreateCar :one
INSERT INTO cars (
make,
model,
year,
license_plate
) VALUES (
$1, $2, $3, $4
) RETURNING id, make, model, year, license_plate, updated_at
`

type CreateCarParams struct {
	Make         string `json:"make"`
	Model        string `json:"model"`
	Year         int32  `json:"year"`
	LicensePlate string `json:"license_plate"`
}

func (q *Queries) CreateCar(ctx context.Context, arg CreateCarParams) (Car, error) {
	row := q.db.QueryRow(ctx, createCar,
		arg.Make,
		arg.Model,
		arg.Year,
		arg.LicensePlate,
	)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.LicensePlate,
		&i.UpdatedAt,
	)
	return i, err
}

const createFuelConsumption = `-- name: CreateFuelConsumption :one
INSERT INTO car_fuel_consumption (
car_id,
liters_of_fuel,
cost_in_ksh,
fuel_date,
transaction_id
) VALUES (
 $1, $2, $3, $4, $5
) RETURNING consumption_id, car_id, liters_of_fuel, cost_in_ksh, fuel_date, transaction_id, updated_at
`

type CreateFuelConsumptionParams struct {
	CarID         int32     `json:"car_id"`
	LitersOfFuel  *float64  `json:"liters_of_fuel"`
	CostInKsh     float64   `json:"cost_in_ksh"`
	FuelDate      time.Time `json:"fuel_date"`
	TransactionID *int32    `json:"transaction_id"`
}

func (q *Queries) CreateFuelConsumption(ctx context.Context, arg CreateFuelConsumptionParams) (CarFuelConsumption, error) {
	row := q.db.QueryRow(ctx, createFuelConsumption,
		arg.CarID,
		arg.LitersOfFuel,
		arg.CostInKsh,
		arg.FuelDate,
		arg.TransactionID,
	)
	var i CarFuelConsumption
	err := row.Scan(
		&i.ConsumptionID,
		&i.CarID,
		&i.LitersOfFuel,
		&i.CostInKsh,
		&i.FuelDate,
		&i.TransactionID,
		&i.UpdatedAt,
	)
	return i, err
}

const getCarById = `-- name: GetCarById :one
SELECT id, make, model, year, license_plate, updated_at FROM cars WHERE id = $1
`

func (q *Queries) GetCarById(ctx context.Context, id int32) (Car, error) {
	row := q.db.QueryRow(ctx, getCarById, id)
	var i Car
	err := row.Scan(
		&i.ID,
		&i.Make,
		&i.Model,
		&i.Year,
		&i.LicensePlate,
		&i.UpdatedAt,
	)
	return i, err
}

const getCars = `-- name: GetCars :many
SELECT id, make, model, year, license_plate, updated_at FROM cars LIMIT $1 OFFSET $2
`

type GetCarsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetCars(ctx context.Context, arg GetCarsParams) ([]Car, error) {
	rows, err := q.db.Query(ctx, getCars, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Car{}
	for rows.Next() {
		var i Car
		if err := rows.Scan(
			&i.ID,
			&i.Make,
			&i.Model,
			&i.Year,
			&i.LicensePlate,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConsumptionByCar = `-- name: GetConsumptionByCar :many
SELECT consumption_id, car_id, liters_of_fuel, cost_in_ksh, fuel_date, transaction_id, updated_at FROM car_fuel_consumption WHERE car_id = $1
`

func (q *Queries) GetConsumptionByCar(ctx context.Context, carID int32) ([]CarFuelConsumption, error) {
	rows, err := q.db.Query(ctx, getConsumptionByCar, carID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CarFuelConsumption{}
	for rows.Next() {
		var i CarFuelConsumption
		if err := rows.Scan(
			&i.ConsumptionID,
			&i.CarID,
			&i.LitersOfFuel,
			&i.CostInKsh,
			&i.FuelDate,
			&i.TransactionID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConsumptionByCarAndDateRange = `-- name: GetConsumptionByCarAndDateRange :many
SELECT consumption_id, car_id, liters_of_fuel, cost_in_ksh, fuel_date, transaction_id, updated_at FROM car_fuel_consumption WHERE car_id = $1 AND fuel_date BETWEEN $2 AND $3
`

type GetConsumptionByCarAndDateRangeParams struct {
	CarID      int32     `json:"car_id"`
	FuelDate   time.Time `json:"fuel_date"`
	FuelDate_2 time.Time `json:"fuel_date_2"`
}

func (q *Queries) GetConsumptionByCarAndDateRange(ctx context.Context, arg GetConsumptionByCarAndDateRangeParams) ([]CarFuelConsumption, error) {
	rows, err := q.db.Query(ctx, getConsumptionByCarAndDateRange, arg.CarID, arg.FuelDate, arg.FuelDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CarFuelConsumption{}
	for rows.Next() {
		var i CarFuelConsumption
		if err := rows.Scan(
			&i.ConsumptionID,
			&i.CarID,
			&i.LitersOfFuel,
			&i.CostInKsh,
			&i.FuelDate,
			&i.TransactionID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConsumptions = `-- name: GetConsumptions :many
SELECT consumption_id, car_id, liters_of_fuel, cost_in_ksh, fuel_date, transaction_id, updated_at FROM car_fuel_consumption LIMIT $1 OFFSET $2
`

type GetConsumptionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetConsumptions(ctx context.Context, arg GetConsumptionsParams) ([]CarFuelConsumption, error) {
	rows, err := q.db.Query(ctx, getConsumptions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CarFuelConsumption{}
	for rows.Next() {
		var i CarFuelConsumption
		if err := rows.Scan(
			&i.ConsumptionID,
			&i.CarID,
			&i.LitersOfFuel,
			&i.CostInKsh,
			&i.FuelDate,
			&i.TransactionID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
