// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: payments.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgtype"
)

const approvePaymentRequest = `-- name: ApprovePaymentRequest :one
UPDATE payment_requests
SET
status = $1,
approval_date = $2,
admin_id = $3

WHERE request_id = $4 AND lower(status) ='pending'
RETURNING request_id, payment_request_no, amount_in_words, employee_id, currency, amount, description, request_date, status, admin_id, approval_date, invoice_id, pdf_url
`

type ApprovePaymentRequestParams struct {
	Status       string     `json:"status"`
	ApprovalDate *time.Time `json:"approval_date"`
	AdminID      *int32     `json:"admin_id"`
	RequestID    int32      `json:"request_id"`
}

func (q *Queries) ApprovePaymentRequest(ctx context.Context, arg ApprovePaymentRequestParams) (PaymentRequest, error) {
	row := q.db.QueryRow(ctx, approvePaymentRequest,
		arg.Status,
		arg.ApprovalDate,
		arg.AdminID,
		arg.RequestID,
	)
	var i PaymentRequest
	err := row.Scan(
		&i.RequestID,
		&i.PaymentRequestNo,
		&i.AmountInWords,
		&i.EmployeeID,
		&i.Currency,
		&i.Amount,
		&i.Description,
		&i.RequestDate,
		&i.Status,
		&i.AdminID,
		&i.ApprovalDate,
		&i.InvoiceID,
		&i.PdfUrl,
	)
	return i, err
}

const approvePettyCash = `-- name: ApprovePettyCash :one
UPDATE petty_cash
SET
status = $1,
approved_at = $2,
authorised_by = $3

WHERE transaction_id = $4 AND lower(status) ='pending'
RETURNING transaction_id, petty_cash_no, employee_id, amount, currency_code, description, transaction_date, updated_at, approved_at, folio, debit_account, status, authorised_by, pdf_url
`

type ApprovePettyCashParams struct {
	Status        string     `json:"status"`
	ApprovedAt    *time.Time `json:"approved_at"`
	AuthorisedBy  *int32     `json:"authorised_by"`
	TransactionID int32      `json:"transaction_id"`
}

func (q *Queries) ApprovePettyCash(ctx context.Context, arg ApprovePettyCashParams) (PettyCash, error) {
	row := q.db.QueryRow(ctx, approvePettyCash,
		arg.Status,
		arg.ApprovedAt,
		arg.AuthorisedBy,
		arg.TransactionID,
	)
	var i PettyCash
	err := row.Scan(
		&i.TransactionID,
		&i.PettyCashNo,
		&i.EmployeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Description,
		&i.TransactionDate,
		&i.UpdatedAt,
		&i.ApprovedAt,
		&i.Folio,
		&i.DebitAccount,
		&i.Status,
		&i.AuthorisedBy,
		&i.PdfUrl,
	)
	return i, err
}

const createPaymentRequest = `-- name: CreatePaymentRequest :one
INSERT INTO payment_requests (
employee_id,
currency,
amount,
description,
status,
amount_in_words


) VALUES (
$1, $2, $3, $4, $5, $6
         ) RETURNING request_id, payment_request_no, amount_in_words, employee_id, currency, amount, description, request_date, status, admin_id, approval_date, invoice_id, pdf_url
`

type CreatePaymentRequestParams struct {
	EmployeeID    int32   `json:"employee_id"`
	Currency      string  `json:"currency"`
	Amount        float64 `json:"amount"`
	Description   string  `json:"description"`
	Status        string  `json:"status"`
	AmountInWords string  `json:"amount_in_words"`
}

func (q *Queries) CreatePaymentRequest(ctx context.Context, arg CreatePaymentRequestParams) (PaymentRequest, error) {
	row := q.db.QueryRow(ctx, createPaymentRequest,
		arg.EmployeeID,
		arg.Currency,
		arg.Amount,
		arg.Description,
		arg.Status,
		arg.AmountInWords,
	)
	var i PaymentRequest
	err := row.Scan(
		&i.RequestID,
		&i.PaymentRequestNo,
		&i.AmountInWords,
		&i.EmployeeID,
		&i.Currency,
		&i.Amount,
		&i.Description,
		&i.RequestDate,
		&i.Status,
		&i.AdminID,
		&i.ApprovalDate,
		&i.InvoiceID,
		&i.PdfUrl,
	)
	return i, err
}

const createPettyCash = `-- name: CreatePettyCash :one
INSERT INTO petty_cash (employee_id, amount, description, transaction_date, folio, debit_account)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING transaction_id, petty_cash_no, employee_id, amount, currency_code, description, transaction_date, updated_at, approved_at, folio, debit_account, status, authorised_by, pdf_url
`

type CreatePettyCashParams struct {
	EmployeeID      int32          `json:"employee_id"`
	Amount          pgtype.Numeric `json:"amount"`
	Description     string         `json:"description"`
	TransactionDate time.Time      `json:"transaction_date"`
	Folio           string         `json:"folio"`
	DebitAccount    string         `json:"debit_account"`
}

func (q *Queries) CreatePettyCash(ctx context.Context, arg CreatePettyCashParams) (PettyCash, error) {
	row := q.db.QueryRow(ctx, createPettyCash,
		arg.EmployeeID,
		arg.Amount,
		arg.Description,
		arg.TransactionDate,
		arg.Folio,
		arg.DebitAccount,
	)
	var i PettyCash
	err := row.Scan(
		&i.TransactionID,
		&i.PettyCashNo,
		&i.EmployeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Description,
		&i.TransactionDate,
		&i.UpdatedAt,
		&i.ApprovedAt,
		&i.Folio,
		&i.DebitAccount,
		&i.Status,
		&i.AuthorisedBy,
		&i.PdfUrl,
	)
	return i, err
}

const deletePaymentRequest = `-- name: DeletePaymentRequest :exec
DELETE FROM payment_requests
WHERE request_id = $1
`

func (q *Queries) DeletePaymentRequest(ctx context.Context, requestID int32) error {
	_, err := q.db.Exec(ctx, deletePaymentRequest, requestID)
	return err
}

const deletePettyCash = `-- name: DeletePettyCash :exec
DELETE FROM petty_cash
WHERE transaction_id = $1
`

func (q *Queries) DeletePettyCash(ctx context.Context, transactionID int32) error {
	_, err := q.db.Exec(ctx, deletePettyCash, transactionID)
	return err
}

const getPaymentRequest = `-- name: GetPaymentRequest :one
SELECT request_id, payment_request_no, amount_in_words, employee_id, currency, amount, description, request_date, status, admin_id, approval_date, invoice_id, pdf_url FROM payment_requests WHERE request_id = $1
`

func (q *Queries) GetPaymentRequest(ctx context.Context, requestID int32) (PaymentRequest, error) {
	row := q.db.QueryRow(ctx, getPaymentRequest, requestID)
	var i PaymentRequest
	err := row.Scan(
		&i.RequestID,
		&i.PaymentRequestNo,
		&i.AmountInWords,
		&i.EmployeeID,
		&i.Currency,
		&i.Amount,
		&i.Description,
		&i.RequestDate,
		&i.Status,
		&i.AdminID,
		&i.ApprovalDate,
		&i.InvoiceID,
		&i.PdfUrl,
	)
	return i, err
}

const getPettyCash = `-- name: GetPettyCash :one
SELECT transaction_id, petty_cash_no, employee_id, amount, currency_code, description, transaction_date, updated_at, approved_at, folio, debit_account, status, authorised_by, pdf_url FROM petty_cash WHERE transaction_id = $1
`

func (q *Queries) GetPettyCash(ctx context.Context, transactionID int32) (PettyCash, error) {
	row := q.db.QueryRow(ctx, getPettyCash, transactionID)
	var i PettyCash
	err := row.Scan(
		&i.TransactionID,
		&i.PettyCashNo,
		&i.EmployeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Description,
		&i.TransactionDate,
		&i.UpdatedAt,
		&i.ApprovedAt,
		&i.Folio,
		&i.DebitAccount,
		&i.Status,
		&i.AuthorisedBy,
		&i.PdfUrl,
	)
	return i, err
}

const listEmployeePaymentRequests = `-- name: ListEmployeePaymentRequests :many
SELECT request_id, payment_request_no, amount_in_words, employee_id, currency, amount, description, request_date, status, admin_id, approval_date, invoice_id, pdf_url
FROM payment_requests
WHERE employee_id = $1
ORDER BY request_date DESC
LIMIT $2 OFFSET $3
`

type ListEmployeePaymentRequestsParams struct {
	EmployeeID int32 `json:"employee_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListEmployeePaymentRequests(ctx context.Context, arg ListEmployeePaymentRequestsParams) ([]PaymentRequest, error) {
	rows, err := q.db.Query(ctx, listEmployeePaymentRequests, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentRequest{}
	for rows.Next() {
		var i PaymentRequest
		if err := rows.Scan(
			&i.RequestID,
			&i.PaymentRequestNo,
			&i.AmountInWords,
			&i.EmployeeID,
			&i.Currency,
			&i.Amount,
			&i.Description,
			&i.RequestDate,
			&i.Status,
			&i.AdminID,
			&i.ApprovalDate,
			&i.InvoiceID,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEmployeePettyCash = `-- name: ListEmployeePettyCash :many
SELECT transaction_id, petty_cash_no, employee_id, amount, currency_code, description, transaction_date, updated_at, approved_at, folio, debit_account, status, authorised_by, pdf_url FROM petty_cash
WHERE employee_id = $1
ORDER BY transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListEmployeePettyCashParams struct {
	EmployeeID int32 `json:"employee_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListEmployeePettyCash(ctx context.Context, arg ListEmployeePettyCashParams) ([]PettyCash, error) {
	rows, err := q.db.Query(ctx, listEmployeePettyCash, arg.EmployeeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PettyCash{}
	for rows.Next() {
		var i PettyCash
		if err := rows.Scan(
			&i.TransactionID,
			&i.PettyCashNo,
			&i.EmployeeID,
			&i.Amount,
			&i.CurrencyCode,
			&i.Description,
			&i.TransactionDate,
			&i.UpdatedAt,
			&i.ApprovedAt,
			&i.Folio,
			&i.DebitAccount,
			&i.Status,
			&i.AuthorisedBy,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentRequests = `-- name: ListPaymentRequests :many
SELECT request_id, payment_request_no, amount_in_words, employee_id, currency, amount, description, request_date, status, admin_id, approval_date, invoice_id, pdf_url FROM payment_requests ORDER BY request_date DESC LIMIT $1 OFFSET $2
`

type ListPaymentRequestsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPaymentRequests(ctx context.Context, arg ListPaymentRequestsParams) ([]PaymentRequest, error) {
	rows, err := q.db.Query(ctx, listPaymentRequests, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PaymentRequest{}
	for rows.Next() {
		var i PaymentRequest
		if err := rows.Scan(
			&i.RequestID,
			&i.PaymentRequestNo,
			&i.AmountInWords,
			&i.EmployeeID,
			&i.Currency,
			&i.Amount,
			&i.Description,
			&i.RequestDate,
			&i.Status,
			&i.AdminID,
			&i.ApprovalDate,
			&i.InvoiceID,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPettyCash = `-- name: ListPettyCash :many
SELECT transaction_id, petty_cash_no, employee_id, amount, currency_code, description, transaction_date, updated_at, approved_at, folio, debit_account, status, authorised_by, pdf_url FROM petty_cash ORDER BY transaction_date LIMIT $1 OFFSET $2
`

type ListPettyCashParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPettyCash(ctx context.Context, arg ListPettyCashParams) ([]PettyCash, error) {
	rows, err := q.db.Query(ctx, listPettyCash, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PettyCash{}
	for rows.Next() {
		var i PettyCash
		if err := rows.Scan(
			&i.TransactionID,
			&i.PettyCashNo,
			&i.EmployeeID,
			&i.Amount,
			&i.CurrencyCode,
			&i.Description,
			&i.TransactionDate,
			&i.UpdatedAt,
			&i.ApprovedAt,
			&i.Folio,
			&i.DebitAccount,
			&i.Status,
			&i.AuthorisedBy,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentRequest = `-- name: UpdatePaymentRequest :one
UPDATE payment_requests
SET
    employee_id = COALESCE($1, employee_id),
    amount = COALESCE($2, amount),
    description = COALESCE($3, description),
    invoice_id = COALESCE($4, invoice_id),
    admin_id = COALESCE($5, admin_id)
WHERE request_id = $6 AND lower(status) ='pending'
RETURNING request_id, payment_request_no, amount_in_words, employee_id, currency, amount, description, request_date, status, admin_id, approval_date, invoice_id, pdf_url
`

type UpdatePaymentRequestParams struct {
	EmployeeID  int32   `json:"employee_id"`
	Amount      float64 `json:"amount"`
	Description string  `json:"description"`
	InvoiceID   *int32  `json:"invoice_id"`
	AdminID     *int32  `json:"admin_id"`
	RequestID   int32   `json:"request_id"`
}

func (q *Queries) UpdatePaymentRequest(ctx context.Context, arg UpdatePaymentRequestParams) (PaymentRequest, error) {
	row := q.db.QueryRow(ctx, updatePaymentRequest,
		arg.EmployeeID,
		arg.Amount,
		arg.Description,
		arg.InvoiceID,
		arg.AdminID,
		arg.RequestID,
	)
	var i PaymentRequest
	err := row.Scan(
		&i.RequestID,
		&i.PaymentRequestNo,
		&i.AmountInWords,
		&i.EmployeeID,
		&i.Currency,
		&i.Amount,
		&i.Description,
		&i.RequestDate,
		&i.Status,
		&i.AdminID,
		&i.ApprovalDate,
		&i.InvoiceID,
		&i.PdfUrl,
	)
	return i, err
}

const updatePettyCash = `-- name: UpdatePettyCash :one
UPDATE petty_cash
SET
    amount = COALESCE($1, amount),
    description = COALESCE($2, description)
WHERE transaction_id = $3 AND lower(status) ='pending'
RETURNING transaction_id, petty_cash_no, employee_id, amount, currency_code, description, transaction_date, updated_at, approved_at, folio, debit_account, status, authorised_by, pdf_url
`

type UpdatePettyCashParams struct {
	Amount        pgtype.Numeric `json:"amount"`
	Description   string         `json:"description"`
	TransactionID int32          `json:"transaction_id"`
}

func (q *Queries) UpdatePettyCash(ctx context.Context, arg UpdatePettyCashParams) (PettyCash, error) {
	row := q.db.QueryRow(ctx, updatePettyCash, arg.Amount, arg.Description, arg.TransactionID)
	var i PettyCash
	err := row.Scan(
		&i.TransactionID,
		&i.PettyCashNo,
		&i.EmployeeID,
		&i.Amount,
		&i.CurrencyCode,
		&i.Description,
		&i.TransactionDate,
		&i.UpdatedAt,
		&i.ApprovedAt,
		&i.Folio,
		&i.DebitAccount,
		&i.Status,
		&i.AuthorisedBy,
		&i.PdfUrl,
	)
	return i, err
}
