// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: invoice.sql

package db

import (
	"context"
)

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO invoices (purchase_order_number, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, invoice_no, purchase_order_number, date, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received, pdf_url
`

type CreateInvoiceParams struct {
	PurchaseOrderNumber string  `json:"purchase_order_number"`
	Attn                string  `json:"attn"`
	CompanyID           int32   `json:"company_id"`
	Site                string  `json:"site"`
	AmountDue           float64 `json:"amount_due"`
	BankDetails         int32   `json:"bank_details"`
	SignatoryID         int32   `json:"signatory_id"`
	SentOrReceived      string  `json:"sent_or_received"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.PurchaseOrderNumber,
		arg.Attn,
		arg.CompanyID,
		arg.Site,
		arg.AmountDue,
		arg.BankDetails,
		arg.SignatoryID,
		arg.SentOrReceived,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNo,
		&i.PurchaseOrderNumber,
		&i.Date,
		&i.Attn,
		&i.CompanyID,
		&i.Site,
		&i.AmountDue,
		&i.BankDetails,
		&i.SignatoryID,
		&i.SentOrReceived,
		&i.PdfUrl,
	)
	return i, err
}

const getInvoiceById = `-- name: GetInvoiceById :one
SELECT id, invoice_no, purchase_order_number, date, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received, pdf_url FROM invoices WHERE id = $1
`

func (q *Queries) GetInvoiceById(ctx context.Context, id int32) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceById, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNo,
		&i.PurchaseOrderNumber,
		&i.Date,
		&i.Attn,
		&i.CompanyID,
		&i.Site,
		&i.AmountDue,
		&i.BankDetails,
		&i.SignatoryID,
		&i.SentOrReceived,
		&i.PdfUrl,
	)
	return i, err
}

const getInvoicesByPurchaseOrderNumber = `-- name: GetInvoicesByPurchaseOrderNumber :many
SELECT id, invoice_no, purchase_order_number, date, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received, pdf_url FROM invoices WHERE purchase_order_number = $1
`

func (q *Queries) GetInvoicesByPurchaseOrderNumber(ctx context.Context, purchaseOrderNumber string) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, getInvoicesByPurchaseOrderNumber, purchaseOrderNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNo,
			&i.PurchaseOrderNumber,
			&i.Date,
			&i.Attn,
			&i.CompanyID,
			&i.Site,
			&i.AmountDue,
			&i.BankDetails,
			&i.SignatoryID,
			&i.SentOrReceived,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoices = `-- name: ListInvoices :many
SELECT id, invoice_no, purchase_order_number, date, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received, pdf_url FROM invoices
LIMIT $1 OFFSET $2
`

type ListInvoicesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListInvoices(ctx context.Context, arg ListInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoices, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNo,
			&i.PurchaseOrderNumber,
			&i.Date,
			&i.Attn,
			&i.CompanyID,
			&i.Site,
			&i.AmountDue,
			&i.BankDetails,
			&i.SignatoryID,
			&i.SentOrReceived,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSiteInvoices = `-- name: ListSiteInvoices :many
SELECT id, invoice_no, purchase_order_number, date, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received, pdf_url FROM invoices WHERE site = $1
LIMIT $2 OFFSET $3
`

type ListSiteInvoicesParams struct {
	Site   string `json:"site"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListSiteInvoices(ctx context.Context, arg ListSiteInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listSiteInvoices, arg.Site, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNo,
			&i.PurchaseOrderNumber,
			&i.Date,
			&i.Attn,
			&i.CompanyID,
			&i.Site,
			&i.AmountDue,
			&i.BankDetails,
			&i.SignatoryID,
			&i.SentOrReceived,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserCompanyInvoices = `-- name: ListUserCompanyInvoices :many
SELECT id, invoice_no, purchase_order_number, date, attn, company_id, site, amount_due, bank_details, signatory_id, sent_or_received, pdf_url FROM invoices WHERE company_id = $1
LIMIT $2 OFFSET $3
`

type ListUserCompanyInvoicesParams struct {
	CompanyID int32 `json:"company_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListUserCompanyInvoices(ctx context.Context, arg ListUserCompanyInvoicesParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listUserCompanyInvoices, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNo,
			&i.PurchaseOrderNumber,
			&i.Date,
			&i.Attn,
			&i.CompanyID,
			&i.Site,
			&i.AmountDue,
			&i.BankDetails,
			&i.SignatoryID,
			&i.SentOrReceived,
			&i.PdfUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
