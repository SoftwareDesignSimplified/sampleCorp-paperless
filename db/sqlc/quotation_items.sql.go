// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: quotation_items.sql

package db

import (
	"context"
)

const createQuotationItem = `-- name: CreateQuotationItem :one
INSERT INTO quotation_items (
    description,
    uom,
    qty,
    lead_time,
    item_price,
    disc,
    unit_price,
    net_price,
    currency,
    quotation_id
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
         ) RETURNING id, description, uom, qty, lead_time, item_price, disc, unit_price, net_price, currency, quotation_id
`

type CreateQuotationItemParams struct {
	Description string  `json:"description"`
	Uom         string  `json:"uom"`
	Qty         int32   `json:"qty"`
	LeadTime    string  `json:"lead_time"`
	ItemPrice   float64 `json:"item_price"`
	Disc        float64 `json:"disc"`
	UnitPrice   float64 `json:"unit_price"`
	NetPrice    float64 `json:"net_price"`
	Currency    string  `json:"currency"`
	QuotationID int32   `json:"quotation_id"`
}

func (q *Queries) CreateQuotationItem(ctx context.Context, arg CreateQuotationItemParams) (QuotationItem, error) {
	row := q.db.QueryRow(ctx, createQuotationItem,
		arg.Description,
		arg.Uom,
		arg.Qty,
		arg.LeadTime,
		arg.ItemPrice,
		arg.Disc,
		arg.UnitPrice,
		arg.NetPrice,
		arg.Currency,
		arg.QuotationID,
	)
	var i QuotationItem
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Uom,
		&i.Qty,
		&i.LeadTime,
		&i.ItemPrice,
		&i.Disc,
		&i.UnitPrice,
		&i.NetPrice,
		&i.Currency,
		&i.QuotationID,
	)
	return i, err
}

const getQuotationItemsByQuotationID = `-- name: GetQuotationItemsByQuotationID :many
SELECT id, description, uom, qty, lead_time, item_price, disc, unit_price, net_price, currency, quotation_id
FROM quotation_items
WHERE quotation_id = $1
`

func (q *Queries) GetQuotationItemsByQuotationID(ctx context.Context, quotationID int32) ([]QuotationItem, error) {
	rows, err := q.db.Query(ctx, getQuotationItemsByQuotationID, quotationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuotationItem{}
	for rows.Next() {
		var i QuotationItem
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Uom,
			&i.Qty,
			&i.LeadTime,
			&i.ItemPrice,
			&i.Disc,
			&i.UnitPrice,
			&i.NetPrice,
			&i.Currency,
			&i.QuotationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuotationItemsByQuotationID = `-- name: ListQuotationItemsByQuotationID :many
SELECT id, description, uom, qty, lead_time, item_price, disc, unit_price, net_price, currency, quotation_id FROM quotation_items WHERE quotation_id = $1
`

func (q *Queries) ListQuotationItemsByQuotationID(ctx context.Context, quotationID int32) ([]QuotationItem, error) {
	rows, err := q.db.Query(ctx, listQuotationItemsByQuotationID, quotationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuotationItem{}
	for rows.Next() {
		var i QuotationItem
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Uom,
			&i.Qty,
			&i.LeadTime,
			&i.ItemPrice,
			&i.Disc,
			&i.UnitPrice,
			&i.NetPrice,
			&i.Currency,
			&i.QuotationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateQuotationItem = `-- name: UpdateQuotationItem :one
UPDATE quotation_items
SET
    description = COALESCE($1, description),
    uom = COALESCE($2, uom),
    qty = COALESCE($3, qty),
    lead_time = COALESCE($4, lead_time),
    item_price = COALESCE($5, item_price),
    disc = COALESCE($6, disc),
    unit_price = COALESCE($7, unit_price),
    net_price = COALESCE($8, net_price),
    currency = COALESCE($9, currency),
    quotation_id = COALESCE($10, quotation_id)
WHERE id = $11
RETURNING id, description, uom, qty, lead_time, item_price, disc, unit_price, net_price, currency, quotation_id
`

type UpdateQuotationItemParams struct {
	Description string  `json:"description"`
	Uom         string  `json:"uom"`
	Qty         int32   `json:"qty"`
	LeadTime    string  `json:"lead_time"`
	ItemPrice   float64 `json:"item_price"`
	Disc        float64 `json:"disc"`
	UnitPrice   float64 `json:"unit_price"`
	NetPrice    float64 `json:"net_price"`
	Currency    string  `json:"currency"`
	QuotationID int32   `json:"quotation_id"`
	ID          int32   `json:"id"`
}

func (q *Queries) UpdateQuotationItem(ctx context.Context, arg UpdateQuotationItemParams) (QuotationItem, error) {
	row := q.db.QueryRow(ctx, updateQuotationItem,
		arg.Description,
		arg.Uom,
		arg.Qty,
		arg.LeadTime,
		arg.ItemPrice,
		arg.Disc,
		arg.UnitPrice,
		arg.NetPrice,
		arg.Currency,
		arg.QuotationID,
		arg.ID,
	)
	var i QuotationItem
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Uom,
		&i.Qty,
		&i.LeadTime,
		&i.ItemPrice,
		&i.Disc,
		&i.UnitPrice,
		&i.NetPrice,
		&i.Currency,
		&i.QuotationID,
	)
	return i, err
}
